private class AutoGeneratedClass
{
    public List<Item> m_batchItems;

    public void WaitCallback(object o)
    {
        DataContext db = new DataContext();
        db.Items.InsertAllOnSubmit(this.m_batchItems);
        db.SubmitChanges();
    }
}

static void Process()
{ 
    var helper = new AutoGeneratedClass();
    helper.m_batchItems = new List<Item>();

    foreach (var item in ...)
    {
        helper.m_batchItems.Add(item);

        if (helper.m_batchItems.Count > 1000)
        {
            ThreadPool.QueueUserWorkItem(helper.WaitCallback);
            helper.m_batchItems = new List<Item>();
        }
    }
}

/*
编译器会自动生成一个AutoGeneratedClass类，并且在Process方法中使用这个类的实例来代替原来的batchItems局部变量。同样，交给ThreadPool的委托对象也从匿名方法变成了AutoGeneratedClass实例的公有方法。因此线程池每次调用的便是该实例的WaitCallback方法。

现在问题应该一目了然了吧？每次把委托交给线程池之后，线程池并不会立即执行，而会保留到合适的时间再进行。而WaitCallback方法在执行时，它会读取m_batchItems这个Field字段“当前”所引用的对象。而与此同时，Process方法已经“抛弃”了原本我们要提交的数据，因此会引起提交到数据库中数据的丢失。同时，在准备每批次数据的过程中，很有可能会发起两次数据提交，两个线程提交同样一批Item时，就抛出了所谓“莫名其妙”的异常。
*/